<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | My Octopress Blog]]></title>
  <link href="http://IamAlchemist.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://IamAlchemist.github.io/"/>
  <updated>2015-07-13T08:36:28+08:00</updated>
  <id>http://IamAlchemist.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AIDL in Android]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/07/12/aidl-in-android/"/>
    <updated>2015-07-12T13:11:59+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/07/12/aidl-in-android</id>
    <content type="html"><![CDATA[<p>AIDL是用来跨进行通信的。在Android上，跨进程通信需要把对象解构成系统可以识别的基本类型，然后在交给另一个进程使用之前，需要重新组装起来。这些工作是十分枯燥的，AIDL就是为了这个目的而设计的。</p>

<p><code>注意：当且仅当你允许不同的App的clients需要跨进程来访问你的service，并且需要在service里处理多线程问题的时候，你才应该使用AIDL。如果仅仅是App内部的client来访问服务，并且不需要IPC的话，只要使用Binder就好了。如果是需要IPC，但是不用处理并发的话，那么只要用Messager就好了。只有既要IPC，又要处理并发，才需要用AIDL。总之，只有在必须的时候才使用AIDL</code></p>

<!--more-->


<h3>关于AIDL调用的背后</h3>

<p>另一个需要知道的是，AIDL的接口调用是直接调用，所以并不能对调用接口的线程有任何假设。调用的线程在本地进程执行还是在远程进程执行的结果可能是非常不同的。其中：</p>

<ul>
<li>如果是本地进程进行AIDL调用，服务端代码是在进行调用的这个线程中执行的</li>
<li>如果是远程进程进行AIDL调用，你就必须为服务端代码同时在不同线程中执行做好准备，也就是说，这些代码必须是线程安全的</li>
<li><code>oneway</code>关键字用来修饰远调用，使用后表示这个远程调用并不阻塞，它仅仅是发送了数据就立刻返回。而该关键字并不影响本地调用</li>
</ul>


<h3>创建AIDL过程</h3>

<ul>
<li>创建.aidl文件</li>
</ul>


<p>使用Android Studio自己创建IRemoteService.aidl就很好，比如定义接口getPid()</p>

<pre><code>interface IRemoteService {
    int getPid();
}
</code></pre>

<ul>
<li>实现该接口的service</li>
</ul>


<p>例如实现文件AIDLService.java，这个service在onBind函数中返回的binder里含有IRemoteService.aidl定义的接口的实现</p>

<pre><code>public class AIDLService extends Service {

    private final IRemoteService.Stub binder = new IRemoteService.Stub(){

        @Override
        public int getPid() throws RemoteException {
            return android.os.Process.myPid();
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }
}
</code></pre>

<ul>
<li>使用该AIDL</li>
</ul>


<p>像使用普通service一样</p>

<pre><code>IRemoteService remoteService;

ServiceConnection remoteServiceConnection = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
        remoteService = IRemoteService.Stub.asInterface(iBinder);
    }

    @Override
    public void onServiceDisconnected(ComponentName componentName) {
        remoteService = null;
    }
};

Intent intent = new Intent(MainActivity.this, AIDLService.class);
bindService(intent, remoteServiceConnection, BIND_AUTO_CREATE);
startService(intent);

int remotePid = remoteService.getPid();
</code></pre>

<h3>在AIDL中传递对象</h3>

<p>比如我们希望AIDL接口可以传递名为Student的对象,需要做以下一些事情</p>

<ul>
<li>定义Student.aidl</li>
</ul>


<p>其中声明Student类型</p>

<pre><code>parcelable Student;
</code></pre>

<ul>
<li>定义aidl接口（IRemoteAPI.aidl）</li>
</ul>


<p>注意要import相应的Student类</p>

<pre><code>import com.morgenworks.alchemistli.remotelibrary.Student;

interface IRemoteAPI {
    Student getName();
    void setName(in Student st);
}
</code></pre>

<ul>
<li>定义实现了Parcelble接口的Student类</li>
</ul>


<p>实现Parcelble接口需要实现这样几个函数, Student(Parcel source), writeToParcel(&hellip;), readescribeContents(), 以及static Creator<Student> CREATOR</p>

<pre><code>public class Student implements Parcelable {
    public String name;
    public String fatherName;

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);
        dest.writeString(fatherName);
    }

    public Student(Parcel source){
        name = source.readString();
        fatherName = source.readString();
    }

    public Student(){}

    public void setName(String name){
        this.name = name;
    }

    public void setFatherName(String fatherName){
        this.fatherName = fatherName;
    }

    public static final Creator&lt;Student&gt; CREATOR = new Creator&lt;Student&gt;() {
        @Override
        public Student createFromParcel(Parcel source) {
            return new Student(source);
        }

        @Override
        public Student[] newArray(int size) {
            return new Student[size];
        }
    };
}
</code></pre>

<ul>
<li>实现AIDL接口的服务</li>
</ul>


<p>就像实现普通的AIDL接口服务一样</p>

<pre><code>public class RemoteAPIService extends Service {
    private Student stuInfo;

    private IRemoteAPI.Stub binder = new IRemoteAPI.Stub() {
        @Override
        public Student getName() throws RemoteException {
            stuInfo.name = stuInfo.name.toUpperCase();
            return stuInfo;
        }

        @Override
        public void setName(Student st) throws RemoteException {
            stuInfo = st;
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Churn]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/06/memory-churn/"/>
    <updated>2015-05-06T13:46:43+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/06/memory-churn</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Preformace 2: Detect Memory Leak]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/05/android-preformace-2-detect-memory-leak/"/>
    <updated>2015-05-05T20:42:43+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/05/android-preformace-2-detect-memory-leak</id>
    <content type="html"><![CDATA[<h3>the common way to detect memory leak</h3>

<!--more-->


<ul>
<li>use Heap tool and Allocation tracing</li>
<li>start a empty activity</li>
<li>jump to the activity in question</li>
<li>trigger gc</li>
<li>watch the heap</li>
</ul>


<p><img class="center" src="/images/android_performace/memory_leak_detection.png" width="600"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Performance 1: Memory Monitor]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/04/android-performance-patther-1/"/>
    <updated>2015-05-04T20:32:24+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/04/android-performance-patther-1</id>
    <content type="html"><![CDATA[<h3>android studio can trace the general memory usage by <em>Memory Moniter</em></h3>

<!--more-->


<p>android studio can trace the general memory usage by <em>Memory Moniter</em><br/>
<img class="center" src="/images/android_performace/memory_moniter.jpg" width="500"></p>

<p>watch the video <a href="https://www.youtube.com/watch?v=7ls28uGMBEs&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=36">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Process in Android]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/11/25/process-in-android/"/>
    <updated>2014-11-25T10:24:54+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/11/25/process-in-android</id>
    <content type="html"><![CDATA[<p>there are four types of components for an App, <activity>, <service>, <receiver> and <provider>, which support &ldquo;android:process&rdquo;.</p>

<!--more-->


<p>one App can have multi-processes via &ldquo;android:process&rdquo;, and multi apps can share one process via share the same Linux user ID and signed with the same</p>

<h3>Process lifecycle</h3>

<ul>
<li>Foreground process</li>
</ul>


<p>A process that is required for what the user is currently doing. A process is considered to be in the foreground if any of the following conditions are true:</p>

<blockquote><p>It hosts an Activity that the user is interacting with (the Activity&rsquo;s onResume() method has been called).</p>

<p>It hosts a Service that&rsquo;s bound to the activity that the user is interacting with.</p>

<p>It hosts a Service that&rsquo;s running &ldquo;in the foreground&#8221;—the service has called startForeground().</p>

<p>It hosts a Service that&rsquo;s executing one of its lifecycle callbacks (onCreate(), onStart(), or onDestroy()).</p>

<p>It hosts a BroadcastReceiver that&rsquo;s executing its onReceive() method.</p></blockquote>

<ul>
<li>Visible Process</li>
</ul>


<p>A process that doesn&rsquo;t have any foreground components, but still can affect what the user sees on screen. A process is considered to be visible if either of the following conditions are true:</p>

<blockquote><p>It hosts an Activity that is not in the foreground, but is still visible to the user (its onPause() method has been called). This might occur, for example, if the foreground activity started a dialog, which allows the previous activity to be seen behind it.</p>

<p>It hosts a Service that&rsquo;s bound to a visible (or foreground) activity.</p></blockquote>

<p>A visible process is considered extremely important and will not be killed unless doing so is required to keep all foreground processes running.</p>

<ul>
<li>Sevice process</li>
</ul>


<p>A process that is running a service that has been started with the startService() method and does not fall into either of the two higher categories. Although service processes are not directly tied to anything the user sees, they are generally doing things that the user cares about (such as playing music in the background or downloading data on the network), so the system keeps them running unless there&rsquo;s not enough memory to retain them along with all foreground and visible processes.</p>

<ul>
<li>Background process</li>
</ul>


<p>A process holding an activity that&rsquo;s not currently visible to the user (the activity&rsquo;s onStop() method has been called). These processes have no direct impact on the user experience, and the system can kill them at any time to reclaim memory for a foreground, visible, or service process. Usually there are many background processes running, so they are kept in an <em>LRU (least recently used)</em> list to ensure that the process with the activity that was most recently seen by the user is the last to be killed. If an activity implements its lifecycle methods correctly, and saves its current state, killing its process will not have a visible effect on the user experience, because when the user navigates back to the activity, the activity restores all of its visible state. See the Activities document for information about saving and restoring state.</p>

<ul>
<li>Empty process
A process that doesn&rsquo;t hold any active application components. The only reason to keep this kind of process alive is for caching purposes, to improve startup time the next time a component needs to run in it. The system often kills these processes in order to balance overall system resources between process caches and the underlying kernel caches.</li>
</ul>


<h3>Threads</h3>

<ul>
<li><p>How to access UI thread from other threads</p>

<blockquote><p>Handler</p>

<p>AsyncTask</p>

<p>Others</p>

<blockquote><p>Activity.runOnUiThread(Runable)</p>

<p>View.post(Runnable)</p>

<p>View.postDelayed(Runnable)</p></blockquote></blockquote></li>
<li><p>Caution 1: need to consider <em>runtime configuration change</em></p></li>
<li><p>Caution 2: need to consider therad-safe</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
