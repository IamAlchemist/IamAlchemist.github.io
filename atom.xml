<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://IamAlchemist.github.io/atom.xml" rel="self"/>
  <link href="http://IamAlchemist.github.io/"/>
  <updated>2015-07-11T17:55:55+08:00</updated>
  <id>http://IamAlchemist.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Method]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/17/swift-method/"/>
    <updated>2015-06-17T12:42:28+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/17/swift-method</id>
    <content type="html"><![CDATA[<p>swift <code>method</code>分为<code>instance method</code>和<code>type method</code></p>

<p><code>instance method</code>是属于实例的函数，<code>type mothod</code>则是属于<code>type</code>的函数</p>

<!--more-->


<h3>Local and External Parameter Names for Method</h3>

<p><code>local and external parameter name</code>的默认行为并不等同于<code>function</code></p>

<p>swift的method的参数名字非常像objective－c。比如说，一般来说，swift的method的名字带有by， with， for等介词，例如incrementBy。</p>

<p>需要指出的是，swift默认会给第一个参数local parameter name，但是对于第二个以后参数则默认生成local and external parameter name。
    class Counter {
        var count : Int = 0
        func incrementBy(amount: Int, numberOfTimes: Int){
            count += amount * numberOfTimes
        }
    }
swift会把amount看作local name，但是会把numberOfTimes看作local and external name。所以调用该method，需要像如下这样
    let counter = Counter()
    counter.incrementBy(5, numberOfTimes: 3)
当然也可以显式的提供第一个参数的external name或者不提供非第一参数的external name
    class Counter2{
        var count : Int = 0
        func incrementBy(#amount: Int, _ numberOfTimes: Int){
            count += amount * numberOfTimes
        }
    }
    let count2 = Count2()
    count2.incrementBy(amount: 5, 3)</p>

<h3>Self Propety</h3>

<p>一般情况下可以不写，但是如果有歧义就需要写
    struct Point{
        var x = 0.0, y = 0.0
        func isToTheRightOfX(x: Double) -> Bool{
            return self.x > x   // must use self
        }
        func description() -> String{
            return &ldquo;x: (x), y: (y)&rdquo;) //no need to use self
        }
    }</p>

<h3>在instance method内改变值类型变量自身</h3>

<p>对于<code>value types</code>来说，一般情况下，instance method不能更改属性，但是加上mutating关键字来改变这点。
    struct Point{
        var x = 0.0, y = 0.0
        mutating func moveByX(deltaX: Double, y deltaY: Double){
            x += deltaX
            y += deltaY
        }
    }</p>

<h3>Assigning to self Within a Mutating Method</h3>

<pre><code>struct Point{
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double){
        self ＝ Point(x: x+deltaX, y: y + deltaY)
    }
}

enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
        switch self {
        case Off:
            self = Low
        case Low:
            self = High
        case High:
            self = Off
        }
    }
}
</code></pre>

<h3>Type Method</h3>

<p><code>type method</code>在类中使用关键字<code>class</code>来表示，在结构体和枚举中使用<code>static</code>来表示</p>

<p>在<code>type method</code>中，<code>self</code>表示类型本身，而不是实例本身</p>

<pre><code>​struct​ ​LevelTracker​ {
​    ​static​ ​var​ ​highestUnlockedLevel​ = ​1
​    ​static​ ​func​ ​unlockLevel​(​level​: ​Int​) {
​        ​if​ ​level​ &gt; ​highestUnlockedLevel​ { ​highestUnlockedLevel​ = ​level​ }
​    }
​    ​static​ ​func​ ​levelIsUnlocked​(​level​: ​Int​) -&gt; ​Bool​ {
​        ​return​ ​level​ &lt;= ​highestUnlockedLevel
​    }
​    ​var​ ​currentLevel​ = ​1
​    ​mutating​ ​func​ ​advanceToLevel​(​level​: ​Int​) -&gt; ​Bool​ {
​        ​if​ ​LevelTracker​.​levelIsUnlocked​(​level​) {
​            ​currentLevel​ = ​level
​            ​return​ ​true
​        } ​else​ {
​            ​return​ ​false
​        }
​    }
​}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Optional Chaining]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/17/swift-optional-chaining/"/>
    <updated>2015-06-17T09:19:59+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/17/swift-optional-chaining</id>
    <content type="html"><![CDATA[<p><code>optinal chainging</code>是一个查询和调用<code>optional</code>的property, method, subscript的过程。如果其中的<code>optional</code>没有nil，那么表达式求值成功。否则，失败。失败后返回nil。所以整个表达式返回值始终是<code>optional</code>类型。</p>

<!--more-->


<p>以下是一些sample code, 先构造一些类</p>

<pre><code>class Person{ var residence: Residence? }

class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int { return rooms.count }

    subscript(i: Int) -&gt; Room {
        get { return rooms[i] }
        set { rooms[i] = newValue }
    }

    func printNumberOfRooms(){
        println("The number of rooms is \(numberOfRooms)")
    }
}

class Room {
    let name: String
    init(name: String){ self.name = name }
}

class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?

    func buildingIdentifier() -&gt; String? {
        if buildingName != nil {
            return buildingName
        } else if buildNumber != nil {
            return buldingNumber
        } else {
            return nil
        }
    }
}
</code></pre>

<p>下面就是如何使用<code>optional chain</code></p>

<pre><code>let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    println("john's residence has \(roomCount) rooms.")
}
// will print nothing

let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress //will fail
</code></pre>

<p>Residence里的方法printNumberOfRooms()没有返回值，但是这意味着该方法返回类型是Void，也就是返回值是(),也就是一个空的tuple. 在<code>optional chain</code>里，会返回Void?</p>

<pre><code>if john.residence?.printNumberOfRoom() != nil {
    println("It was possible to print the number of rooms."
} 
// will print nothing
</code></pre>

<p>对于通过<code>optional chain</code>来设置属性也一样</p>

<pre><code>if (john.residence?.address = someAddress) != nil {
    println("It was possible to set the address."
}
// will print nothing
</code></pre>

<p>通过<code>optional chaining</code>访问subscript</p>

<pre><code>if let firstRoomName = john.residence?[0].name {
    println("the first room name is \(firstRoomName)")
}
// will print nothing

let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse

if let firstRoomName = john.residence?[0].name {
    println("the first room name is \(firstRoomName)")
}
// prints "the first room name is Living Room"
</code></pre>

<p>访问<code>optional</code>的subscript</p>

<pre><code>var testScrores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0]++
testScores["Brain"]?[0]
</code></pre>

<p>多层的optional chain， 原则是
* 如果试图查询的东西的类型并非是<code>optional</code>的，会由于使用了chain而变成<code>optional</code>
* 如果正在查询的东西已经是<code>optional</code>的，它不会因为chain变得“更”<code>optional</code>（<code>optional</code>的<code>optional</code>)</p>

<p>下面是代码示例</p>

<pre><code>if let johnsStreet = john.residence?.address?.street{
    println("John's street name is \(johnsStreet)")
}
// print nothing

let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence?.address = johnsAddress

if let johnsStreet = john.residence?.address?.street{
    println("John's street name is \(johnsStreet)")
}
// print "John's street name is Laurel Street"

if let beginsWithThe = john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
    if beginWithThe {
        println("John's building identifier begins with \"The\".")
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Extension]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/17/swift-extension/"/>
    <updated>2015-06-17T07:45:07+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/17/swift-extension</id>
    <content type="html"><![CDATA[<p><code>extensions</code>可以给已有的type增加功能，而且不必访问源代码(<code>retroactive modeling</code>)</p>

<p><code>extensions</code>可以
* 增加<code>computed property</code>和<code>computed static property</code>
* 定义<code>instance methods</code>和<code>type methods</code>
* 提供新的<code>initializers</code>
* 定义<code>subscripts</code>
* 定义和使用新的<code>nested types</code>
* 为一个<code>type</code>实现一个<code>protocol</code></p>

<p><code>extension</code>不可以
* <code>extension</code>可以增加新的<code>funtionality</code>，但是不能覆盖以有的<code>functionality</code>
* <code>extension</code>不能增加<code>stored properties</code>，或者给存在的<code>property</code>增加<code>property observers</code>
* <code>extension</code>不能增加新的<code>designated initializer</code></p>

<!--more-->


<h4>Extension 语法</h4>

<pre><code>extension SomeType {
    ...
}

extiosion SomeType: Someprotocol, AnotherProtocol {
    ...
}
</code></pre>

<p>一个有趣的例子</p>

<pre><code>extension Double {
    var km: Double { return self * 1000.0 }
    var m: Double { return self }
}

let aMarathon = 42.m + 195.m
println("A marathon is \(aMarathon) masters long")
</code></pre>

<h4>Initializers</h4>

<pre><code>struct Size { var width = 0.0, height = 0.0 }
struct Point { var x = 0.0, y = 0.0 }
struct Rect {
    var origin = Point()
    var size = Size()
}

extension Rect{
    init(center: Point, size: Size){
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x:originX, y:originY), size: size)
    }
}
</code></pre>

<h4>Methods</h4>

<pre><code>extension Int{
    func repetitions(task: ()-&gt; ()){
        for i in 0..&lt;self {
            task()
        }
    }
}

3.repetitions{ println("hello") }
</code></pre>

<h4>Mutating Instance Methods</h4>

<pre><code>extension Int {
    mutating func square(){
        self = self * self
    }
}

var someInt = 3.square()
</code></pre>

<h4>Subscripts</h4>

<pre><code>extension Int {
    subscript(var digitIndex: Int) -&gt; Int{
        var decimalBase = 1
        while digitIndex &gt; 0 {
            decimalBase *= 10
            --digitIndex
        }

        return (self / decimalBase) % 10
    }
}

74631295[1] //return 9
</code></pre>

<h4>Nested Tyeps</h4>

<pre><code>extension Int {
    enum Kind {
        case Negative, Zero, Positive
    }

    var kind: Kind {
        switch self {
        case 0: retrun .Zero
        case let x where x &gt; 0: return .Positive
        default: return .Negative
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中optional]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/12/swift-optional/"/>
    <updated>2015-06-12T15:37:14+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/12/swift-optional</id>
    <content type="html"><![CDATA[<p>关于<code>optional</code>，最需要说的是为什么需要<code>optional</code>，比如说在objctive-c中就没有，也是可以表示一个不存在的对象的。只需要用NULL就可以了。但是如何表示一个不存在的value类型的变量呢？比如一个不存在的struture？objective-c就没有太好的办法了，一般来说是用一个特殊值NSNotFound来表示。不过swift可以让一切不存在的变量都为nil，这就是<code>optional</code>的目的</p>

<!--more-->


<p>关于<code>optional</code>，剩下的只是swift里面有关的特殊术语，搞清楚还是很有必要的</p>

<h4>Force Unwrapping</h4>

<p><code>Force Unwarpping</code>指的是把<code>optional</code>对象转化成一个非空的对象</p>

<h4>Optional Binding</h4>

<p>其基本形式是</p>

<pre><code>if let constantName = someOptional

while let constantName = someOptional
</code></pre>

<h4>Implicity Unwrapped Optionals</h4>

<p>一个optinal变量可以定义为<code>implicity unwrapped optionals</code>, 那么使用这个变量的时候就不再需要force unwrap, 一旦unwrap失败，程序会崩溃</p>

<pre><code>var storyboardName : String! = "hello"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的类型转换]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/11/typecastinginswift/"/>
    <updated>2015-06-11T11:34:01+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/11/typecastinginswift</id>
    <content type="html"><![CDATA[<p>Swift中使用<code>as</code>和<code>is</code>运算符来进行类型转换</p>

<!--more-->


<h4>一个类继承的例子</h4>

<pre><code>class MediaItem{
}

class Movie: MediaItem{
    var director : String
    init(director: String){ self.director = director; super.init() }

}

class Song: MediaItem{
    var artist : String
    init(artist: String){ self.artist = artist; super.init() }
}
</code></pre>

<h4>类型检查使用<code>is</code></h4>

<pre><code>let library = [Movie("d1"), Song("a1"), Song("a2"), Movie("d2")]

var movieCount = 0
var songCount = 0

for item in library {
    if item as Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}
</code></pre>

<p>值得一提的是，<code>is</code>不仅仅用来检测有继承关系的类，而且可以用来检测是否实现了某个接口</p>

<pre><code>protocal HasArea{
    var area: Double { get }
}

class Circle: HasArea{
    var radius: Double
    var area: Double { return 3.14 * radius * radius }
    init(radius: Double){ self.radius = radius }
}

var circle = Circle(2.5)
if circle is HasArea {
    println("Area: \(circle.area)")
}
</code></pre>

<h4>类型转换</h4>

<p>可以使用<code>as</code>来进行类型转换</p>

<p>可以用两种方式来使用<code>as</code>, <code>as?</code>和<code>as!</code></p>

<p><code>as?</code>表示不确定该转换是否能成功，<code>as!</code>表示一定会成功，但是如果运行时转换失败的话，程序会崩掉</p>

<pre><code>for item in library {
    if let movie = item as? Movie {
        println("Director: \(movie.director)")
    } else if let song = item as? Song {
        println("Artist: \(song.artist)")
    }
}
</code></pre>

<h4><code>Any</code>和<code>AnyObject</code>的类型转换</h4>

<p>其实，<code>Any</code>和<code>AnyObject</code>的转换和普通的类型转换是一样的。值得说的是为什么swift要有他们两个。</p>

<ul>
<li><code>AnyObject</code>可以代表任何class类型的实例</li>
<li><code>Any</code>却可以代表任何类型的实例，包括funtion类型</li>
</ul>


<p>举两个例子，第一个例子</p>

<pre><code>let someObjects: [AnyObject] = [Movie('d1'),Movie('d1'),Movie('d1')]
for object in someObjects{
    let movie = object as! Movie
    println("Movie director: \(movie.director)")
}
</code></pre>

<p>该例子中，还可以直接cast整个数组</p>

<pre><code>for movie in someObjects as! [Movie] {
    println("Movie director: \(movie.director)")
}
</code></pre>

<p>另外一个是关于<code>Any</code>的例子</p>

<pre><code>var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie("d1"))
things.append({(name: String) -&gt; String in 
    "Hello, \(name)" })

for thing in things{
    switch thing{
        case 0 as Int: 
            println("zero as an Int")
        case 0 as Double:
            println("zero as an Double")
        case let someInt as Int:
            println("an integer value of \(someInt)")
        case let someDouble as Double where someDouble &gt; 0:
            println("a positive double : \(someDouble)")
        case is Double:
            println("some other double value &lt;= 0")
        case let someString as String:
            println("a string value : \(someString)")
        case let (x, y) as (Double, Double) :
            println("an (x,y) point at \(x), \(y)")
        case let movie as Movie:
            println("a movie director: \(movie.director)")
        case let stringConverter as String -&gt; String:
            println(stringConverter("Michael")
        default:
            println("something else")
    }
}
</code></pre>

<p>需要指出，在switch的case语句中，使用的<code>as</code>是强制转换版的，并不写作<code>as?</code>或者<code>as!</code>，在case语句中使用这种检查总是安全的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Initialization]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/10/swift-initialization/"/>
    <updated>2015-06-10T11:22:46+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/10/swift-initialization</id>
    <content type="html"><![CDATA[<h3>swift的初始化</h3>

<p>这里不是要权威的解释initilization，而是想总结一些swift initilizer的特点</p>

<!--more-->


<p>初始化发生在<em>class</em>, <em>structure</em>, <em>enumeration</em>初始准备的过程中。coder可以通过定义<em>initializers</em>来实现初始化。值得注意的是，<em>initializers</em>没有返回值。</p>

<p>此外，class还可以实现一个&#8217;deinitializer&#8217;</p>

<h3>如何定义initializer</h3>

<p>定义initializer需要用关键字<em>init</em></p>

<h3>Simplest initializer</h3>

<pre><code>struct Fahrenhit{
    var temperature: Double
    init(){
        temperature = 32.0
    }
}
</code></pre>

<h3>自定义initializer</h3>

<p>可以使用initializer parameters来自定义initializer</p>

<pre><code>struct Celsius{
    var temperatureInCelsius: Double
    init(fromFahrenhit fahrenhit: Double){
        temperatureInCelsius = (fahrenhit - 32.0)/1.8
    }
    init(fromKelvin kelvin: Double){
        temperatureInCelsius = kelvin - 273.15
    }
}
</code></pre>

<h3>调用initializer</h3>

<p>由于initializer每个参数默认有external name，所以调用的时候一定要写external name</p>

<pre><code>let boilingPoint = Celsius(fromFahrenhit: 212.0)
let freezePoint = Celsius(fromKelvin: 273.15)
</code></pre>

<h3>Default initializer</h3>

<ul>
<li><p>如果structure或者base class没有提供initializer的话，编译器会提供一个默认的init()。</p></li>
<li><p>对于structure来说如果没有任何自定义的initializer的话，编译器会还会提供一个memberwise initializer</p></li>
</ul>


<h3>Initializer Delegation</h3>

<ul>
<li>value类型和class类型的initilizer delegation的规则是不同的</li>
</ul>


<h3>Structure和Enumunation的Intializer Delegation</h3>

<ul>
<li>只能在initializer中调用self.init</li>
</ul>


<h3>Class Inheriantance and Initialization</h3>

<p>class的initializer分为Designated initializer和Convenience initializer</p>

<h4>Designated initializer和Convenience initializer</h4>

<p>Designated initializer是primary initializer，每个class只要要有一个</p>

<pre><code>init(parameters) { statements }
</code></pre>

<p>Convenience initializer是为了方便而存在的，需要通过Designated initializer来初始化，关键字为<em>convenience</em></p>

<pre><code>convenience init(parameters){ statements }
</code></pre>

<h4>Initializer Delegattion for Class Types</h4>

<ul>
<li>Rule1 一个designated initializer必须调用它直接父类的designated initializer</li>
<li>Rule2 一个convenience initializer必须调用它自己的另一个initializer</li>
<li>Rule3 一个convenience initializer必须最终调用它自己的designated initializer</li>
</ul>


<p>可以简单总结为</p>

<ul>
<li>designated initializer必须delegate up</li>
<li>convenience initializer必须delegate across</li>
</ul>


<p>可以看下图</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_1.png" width="600"></p>

<p>下面是一个更复杂的例子</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_2.png" width="600"></p>

<h4>两阶段的初始化</h4>

<p>在初始化过程中，首先所有的类属性都会被赋予初始值，当这一阶段完成之后，然后在被initializer里代码设置其值<br/>
关于这点，swift的编译器会进行一些检查</p>

<ul>
<li><p>safety check 1 : designated initializer在delegates up到superclass initializer之前，必须保证所有属性都被初始化了</p></li>
<li><p>safety check 2 : designated initializer必须先delegate up到superclass initializer才能赋值给继承下来的属性</p></li>
<li><p>safety check 3 : convenience initializer必须先delegate到其他initializer才能修改属性</p></li>
<li><p>safety check 4 : initializer需要第一阶段初始化完成才能修改属性，调用成员方法</p></li>
</ul>


<p>两阶段初始化的具体过程不详细说了，需要知道的是，当内存分配好之后，先由子类的initializer负责初始化自己的属性，然后向上传递控制权，父类做相同的事情，直到根基类。这时候第一阶段初始化就完成了。第二阶段初始化是从顶向下进行，这时候self就可以访问了，同时可以修改访问self的属性了，调用成员函数了。</p>

<h5>第一阶段初始化</h5>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_3.png" width="600"></p>

<h5>第二阶段初始化</h5>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_4.png" width="600"></p>

<h4>Initializer的Inheritance和Override</h4>

<p>原则上，swift不允许initializer继承，但是在下列情况下可以继承</p>

<ul>
<li><p>如果子类没有写任何designated initializer，子类可以继承所有父类的designated initializer</p></li>
<li><p>如果子类提供了所有父类的designated initializer的实现－－无论是继承而来的，还是自己override的，那么自动继承所有的父类的convenience initializer</p></li>
</ul>


<p>下面举个例子：</p>

<pre><code>class Food{
    var name : String
    init(name: String){ self.name = name }
    convenience init() { self.init(name: "[Unnamed]") }
}
</code></pre>

<p>下图显示了initializer chain</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_5.png" width="600"></p>

<pre><code>class RecipeIngredient: Food{
    var quantity : Int
    init(name: String, quantity: Int){
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String){
        self.init(name: name, quantity: 1)
    }
}
</code></pre>

<p>initializer chain如图</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_6.png" width="600"></p>

<pre><code>class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? "OK" : "Not"
        return output
    }
}
</code></pre>

<p>initializer chain如图</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-10_7.png" width="600"></p>

<h4>Failable Initializer</h4>

<p>语法如下</p>

<pre><code>init?(parameters){ statments }
</code></pre>

<p>举个例子来说
    struct Animal{
        let species: String
        init?(species: String){
            if species.isEmpty { return nil }
            self.species = species
        }
    }</p>

<p>通过<em>return nil</em>，我们可以表示初始化失败</p>

<p>可以像如下方式来使用
    let someCreature = Animal(species: &ldquo;&rdquo;)
    if let griaffe = someCreature{ println(&ldquo;no species&rdquo;) }</p>

<h4>Failable Initializer for Enumerations</h4>

<pre><code>enum TemperatureUnit{
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character){
        switch symbol{
        case "K": self = .Kelvin
        case "C": self = .Celsius
        case "K": self = .Fahrenheit
        default:
            return nil
        }
    }
}


if let unknowUnit = TemperatureUnit("X") { println("no such unit") }
</code></pre>

<h4>Automatic Failable Initializer for Enumerations with Raw Value</h4>

<pre><code>enum TemperatureUnit : Character{
    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
}

if let unknowUnit = TemperatureUnit("D"){ println ("no such unit") }
</code></pre>

<h4>Failable Initializer for Classes &amp; Propagation of Initialization Failure</h4>

<p>对于类来说，初始化失败只能在所有属性都已经被设置了初始值之后发生</p>

<pre><code>class Product{
    let name: String!
    init?(name: String){
        self.name = name
        if name.isEmpty { return nil }
    }
}

class CartItem: Product{
    let quantity: Int!
    init?(name: String, quantity: Int){
        self.quantity = quantity
        super.init(name: name)
        if(quantity &lt; 1) { return nil }
    }
}
</code></pre>

<h4>Override a Failable Initializer</h4>

<p>你可以使用non-failable initializer去override父类的failable initializer，但这时就不能再delegate up到failable initilizer</p>

<pre><code>class Document{
    var name: String?
    init() {}
    init?(name: String){
        self.name = name
        if name.isEmpty { return nil }
    }
}

class AutomaticallyNamedDocument: Document{
    override init(){ 
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String){
        super.init()
        if name.isEmpty{ 
            self.name = "[Untitled]"
        }
        else{ 
            self.name = name 
        }
    }
}
</code></pre>

<h4>Required Initializer</h4>

<p><em>required</em> modifier表示该类的每一个子类都必须实现这个initilizer<br/>
在子类实现该initializer时候必须也添加<em>required</em></p>

<pre><code>class SomeClass{
    required init(){ ... }
}

class SomeSubClass{
    required init(){ ... }
}
</code></pre>

<h4>Setting a Default Property Value with a Closure or Function</h4>

<pre><code>class SomeClass{
    let someProperty: SomeType = {
        return someValue
    }()
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用swift生成Frameworks]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/06/09/shi-yong-swiftsheng-cheng-frameworks/"/>
    <updated>2015-06-09T19:04:02+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/06/09/shi-yong-swiftsheng-cheng-frameworks</id>
    <content type="html"><![CDATA[<h3>制作Dynamically Linked Frameworks</h3>

<!--more-->


<h3>一个普通的Swift file</h3>

<pre><code>class SwiftFrameworks {
    init() { println("Class init") }
    func doSomething() { println("Yeah, it works") }
} 
</code></pre>

<p>为了让它可以在framework中工作，需要让所有类和方法都是<em>public</em>的</p>

<pre><code>public class SwiftFrameworks { 
    public init() { println("Class init") } 
    public func doSomething() { println("Yeah, it works") } 
} 
</code></pre>

<h3>建立framework工程</h3>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-09_1.png" width="600"></p>

<h3>添加刚才的swift文件</h3>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-09_4.png" width="600"></p>

<h3>编译</h3>

<p>有时候编译时候并不能产生target，切换一下设备（可能是xcode的bug），然后找到build好的target所在文件夹</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-09_2.png" width="600"></p>

<h3>添加到测试工程中</h3>

<p>把编译好的framework拖拽到测试工程中，之后在embed中添加该framework</p>

<p><img class="center" src="http://IamAlchemist.github.io/images/iOS/2015-06-09_3.png" width="600"></p>

<p>然后</p>

<pre><code>import SwiftFramework
let swiftFramework = SwiftFramework()
swiftFramework.helloWorld()
</code></pre>

<p>大功告成～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Churn]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/06/memory-churn/"/>
    <updated>2015-05-06T13:46:43+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/06/memory-churn</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Preformace 2: Detect Memory Leak]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/05/android-preformace-2-detect-memory-leak/"/>
    <updated>2015-05-05T20:42:43+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/05/android-preformace-2-detect-memory-leak</id>
    <content type="html"><![CDATA[<h3>the common way to detect memory leak</h3>

<!--more-->


<ul>
<li>use Heap tool and Allocation tracing</li>
<li>start a empty activity</li>
<li>jump to the activity in question</li>
<li>trigger gc</li>
<li>watch the heap</li>
</ul>


<p><img class="center" src="http://IamAlchemist.github.io/images/android_performace/memory_leak_detection.png" width="600"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Performance 1: Memory Monitor]]></title>
    <link href="http://IamAlchemist.github.io/blog/2015/05/04/android-performance-patther-1/"/>
    <updated>2015-05-04T20:32:24+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2015/05/04/android-performance-patther-1</id>
    <content type="html"><![CDATA[<h3>android studio can trace the general memory usage by <em>Memory Moniter</em></h3>

<!--more-->


<p>android studio can trace the general memory usage by <em>Memory Moniter</em><br/>
<img class="center" src="http://IamAlchemist.github.io/images/android_performace/memory_moniter.jpg" width="500"></p>

<p>watch the video <a href="https://www.youtube.com/watch?v=7ls28uGMBEs&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=36">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Process in Android]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/11/25/process-in-android/"/>
    <updated>2014-11-25T10:24:54+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/11/25/process-in-android</id>
    <content type="html"><![CDATA[<p>there are four types of components for an App, <activity>, <service>, <receiver> and <provider>, which support &ldquo;android:process&rdquo;.</p>

<!--more-->


<p>one App can have multi-processes via &ldquo;android:process&rdquo;, and multi apps can share one process via share the same Linux user ID and signed with the same</p>

<h3>Process lifecycle</h3>

<ul>
<li>Foreground process</li>
</ul>


<p>A process that is required for what the user is currently doing. A process is considered to be in the foreground if any of the following conditions are true:</p>

<blockquote><p>It hosts an Activity that the user is interacting with (the Activity&rsquo;s onResume() method has been called).</p>

<p>It hosts a Service that&rsquo;s bound to the activity that the user is interacting with.</p>

<p>It hosts a Service that&rsquo;s running &ldquo;in the foreground&#8221;—the service has called startForeground().</p>

<p>It hosts a Service that&rsquo;s executing one of its lifecycle callbacks (onCreate(), onStart(), or onDestroy()).</p>

<p>It hosts a BroadcastReceiver that&rsquo;s executing its onReceive() method.</p></blockquote>

<ul>
<li>Visible Process</li>
</ul>


<p>A process that doesn&rsquo;t have any foreground components, but still can affect what the user sees on screen. A process is considered to be visible if either of the following conditions are true:</p>

<blockquote><p>It hosts an Activity that is not in the foreground, but is still visible to the user (its onPause() method has been called). This might occur, for example, if the foreground activity started a dialog, which allows the previous activity to be seen behind it.</p>

<p>It hosts a Service that&rsquo;s bound to a visible (or foreground) activity.</p></blockquote>

<p>A visible process is considered extremely important and will not be killed unless doing so is required to keep all foreground processes running.</p>

<ul>
<li>Sevice process</li>
</ul>


<p>A process that is running a service that has been started with the startService() method and does not fall into either of the two higher categories. Although service processes are not directly tied to anything the user sees, they are generally doing things that the user cares about (such as playing music in the background or downloading data on the network), so the system keeps them running unless there&rsquo;s not enough memory to retain them along with all foreground and visible processes.</p>

<ul>
<li>Background process</li>
</ul>


<p>A process holding an activity that&rsquo;s not currently visible to the user (the activity&rsquo;s onStop() method has been called). These processes have no direct impact on the user experience, and the system can kill them at any time to reclaim memory for a foreground, visible, or service process. Usually there are many background processes running, so they are kept in an <em>LRU (least recently used)</em> list to ensure that the process with the activity that was most recently seen by the user is the last to be killed. If an activity implements its lifecycle methods correctly, and saves its current state, killing its process will not have a visible effect on the user experience, because when the user navigates back to the activity, the activity restores all of its visible state. See the Activities document for information about saving and restoring state.</p>

<ul>
<li>Empty process
A process that doesn&rsquo;t hold any active application components. The only reason to keep this kind of process alive is for caching purposes, to improve startup time the next time a component needs to run in it. The system often kills these processes in order to balance overall system resources between process caches and the underlying kernel caches.</li>
</ul>


<h3>Threads</h3>

<ul>
<li><p>How to access UI thread from other threads</p>

<blockquote><p>Handler</p>

<p>AsyncTask</p>

<p>Others</p>

<blockquote><p>Activity.runOnUiThread(Runable)</p>

<p>View.post(Runnable)</p>

<p>View.postDelayed(Runnable)</p></blockquote></blockquote></li>
<li><p>Caution 1: need to consider <em>runtime configuration change</em></p></li>
<li><p>Caution 2: need to consider therad-safe</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Package the .so Lib in Android Studio]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/11/24/how-to-package-the-so-lib-in-android-studio/"/>
    <updated>2014-11-24T11:09:59+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/11/24/how-to-package-the-so-lib-in-android-studio</id>
    <content type="html"><![CDATA[<p>change build.Gradle like this:</p>

<pre><code>sourceSets {  
    main {  
        jniLibs.srcDirs = ['libs']  
    }  
}   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's Cookie]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/11/18/whats-cookie/"/>
    <updated>2014-11-18T10:45:25+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/11/18/whats-cookie</id>
    <content type="html"><![CDATA[<!--more-->


<h3>Cookie使用的典型场景</h3>

<ul>
<li>使用用户名和口令，通过 SSL 登录</li>
<li>在服务器的数据库里检查用户名和口令。如果登录成功，建立一个当前时间标签的消息摘要 (比如 MD5) ，并把它保存在cookie和服务器数据库里。把用户的登录时间保存在服务器数据库里面的用户记录里</li>
<li>在进行每个安全事务时（用户处于登录状态的任何事务），把cookie的消息摘要和保存在服务器数据库里的摘要进行比较，如果比较失败，就把用户引导到登录界面</li>
<li>如果第3步检查通过，那么检查当前时间和登录时间之音经过的时间是否超过允许的时间长度。如果用户已经超时，那么就把用户引到登录界面。</li>
<li>如果第3步和第4步都通过了，那么把登录时间重新设置成当前时间，允许事务发生。

<h3>Cookie Sample</h3>

<p>  name=<value>[; expires=<date>][; domain=<domain>][; path=<path>][; secure]</p></li>
</ul>


<h3>Cookie的构成</h3>

<p>在Javascript脚本里，一个cookie 实际就是一个字符串属性。当你读取cookie的值时，就得到一个字符串，里面当前WEB页使用的所有cookies的名称和值。每个cookie除了name名称和value值这两个属性以外，还有四个属性。这些属性是： expires过期时间、 path路径、 domain域、以及 secure安全。</p>

<ul>
<li><p>Expires – 过期时间。指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。</p></li>
<li><p>Path – 路径。指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果&#8221;<a href="http://www.zdnet.com/devhead/index.html">http://www.zdnet.com/devhead/index.html</a>&#8221; 建立了一个cookie，那么在&#8221;<a href="http://www.zdnet.com/devhead/">http://www.zdnet.com/devhead/</a>&ldquo; 目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。这就是说，在&#8221;<a href="http://www.zdnet.com/devhead/stories/articles">http://www.zdnet.com/devhead/stories/articles</a>&rdquo; 里的任何页面都可以访问&#8221;<a href="http://www.zdnet.com/devhead/index.html">http://www.zdnet.com/devhead/index.html</a>&#8221; 建立的cookie。但是，如果&#8221;<a href="http://www.zdnet.com/zdnn/">http://www.zdnet.com/zdnn/</a>&ldquo; 需要访问&#8221;<a href="http://www.zdnet.com/devhead/index.html">http://www.zdnet.com/devhead/index.html</a>&rdquo; 设置的cookies，该怎么办？这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子：如果想让&#8221;<a href="http://www.zdnet.com/devhead/filters/">http://www.zdnet.com/devhead/filters/</a>&ldquo; 和&#8221;<a href="http://www.zdnet.com/devhead/stories/">http://www.zdnet.com/devhead/stories/</a>&#8220;共享cookies，就要把path设成“/devhead”。</p></li>
</ul>


<p>Domain – 域。指定关联的WEB服务器或域。值是域名，比如zdnet.com。这是对path路径属性的一个延伸。如果我们想让catalog.mycompany.com 能够访问shoppingcart.mycompany.com设置的cookies，该怎么办? 我们可以把domain属性设置成“mycompany.com”，并把path属性设置成“/”。FYI：不能把cookies域属性设置成与设置它的服务器的所在域不同的值。</p>

<p>Secure – 安全。指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Lock the Screen in Mac]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/10/30/how-to-lock-the-screen-in-mac/"/>
    <updated>2014-10-30T16:46:20+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/10/30/how-to-lock-the-screen-in-mac</id>
    <content type="html"><![CDATA[<pre><code>    '/System/Library/CoreServices/Menu Extras/User.menu/Contents/Resources/CGSession' -suspend
</code></pre>

<!--more-->


<ul>
<li>use &ldquo;Automator&rdquo; create a service, then set the input as &ldquo;no input&rdquo;.</li>
<li><p>drag &ldquo;Run shell script&rdquo; to the editor in right side, then</p>

<pre><code>  '/System/Library/CoreServices/Menu Extras/User.menu/Contents/Resources/CGSession' -suspend
</code></pre></li>
<li><p>save the service as &ldquo;lockscreen&rdquo;</p></li>
<li>set the shortcut key for the service in keyboard->shortcut keys</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Core Objects for App]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/10/27/the-core-objects-for-app/"/>
    <updated>2014-10-27T14:20:29+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/10/27/the-core-objects-for-app</id>
    <content type="html"><![CDATA[<ul>
<li>Key objects in a single-window app</li>
<li>Key objects in a multi-window app</li>
<li>Windows and menus displayed by apps &amp; the system</li>
</ul>


<!--more-->


<ul>
<li><p>Key objects in a single-window app
<img src="http://IamAlchemist.github.io/images/single-window-app.png"></p></li>
<li><p>Key objects in a multi-window app
<img src="http://IamAlchemist.github.io/images/multi-window-app.png"></p></li>
<li><p>Windows and menus displayed by apps &amp; the system
<img src="http://IamAlchemist.github.io/images/window_layer_image.png"></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Glance at App Design Pattern]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/10/24/a-glance-at-app-design-pattern/"/>
    <updated>2014-10-24T18:09:53+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/10/24/a-glance-at-app-design-pattern</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li><p>Model-View-Controller
<img src="http://IamAlchemist.github.io/images/model_view_controller.png"></p></li>
<li><p>Delegation: Action on Behalf of Another Object
<img src="http://IamAlchemist.github.io/images/delegation.png"></p></li>
<li><p>Protocol: Enabling Communication Between Objects Not Related by Inheritance
<img src="http://IamAlchemist.github.io/images/protocol.png"></p></li>
<li><p>Notification Center: Nofifying Interested Observers of an Event
<img src="http://IamAlchemist.github.io/images/notificationcenter.png"></p></li>
<li><p>Target-Action: Encapsulating a Message to be Sent When an Event Occurs
<img src="http://IamAlchemist.github.io/images/target_action.png"></p></li>
<li><p>Key-Value Observing: Notifying an Observer When a Value Changes
<img src="http://IamAlchemist.github.io/images/kvo.png"></p></li>
<li><p>View hierarchy</p></li>
<li>Responder chain</li>
<li>Receptionist</li>
<li>Category</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown Syntax]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/09/29/mark-syntax/"/>
    <updated>2014-09-29T22:35:48+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/09/29/mark-syntax</id>
    <content type="html"><![CDATA[<pre><code>#h1
###h3
######h6

&gt;this is a
pargraph, haha

* Red
* Blue


markdown paragraph .... between emtpy lines

this is a paragraph

this is a H1
=

this is a H2
-

*  This is a list item with two paragraphs. Lorem ipsum dolor
   sit amet, consectetuer adipiscing elit. Aliquam hendrerit
   mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
        sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.

****

*thex*
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Publish the Blog]]></title>
    <link href="http://IamAlchemist.github.io/blog/2014/09/29/how-to-publish-the-blog/"/>
    <updated>2014-09-29T21:37:35+08:00</updated>
    <id>http://IamAlchemist.github.io/blog/2014/09/29/how-to-publish-the-blog</id>
    <content type="html"><![CDATA[<pre><code>rake new_post["title"]
rake generate
rake watch
rake preview
rake deploy

git add .
git commit -m "new blog"
git push origin source

cd _deploy
git push -u gitcafe master:gitcafe-pages
</code></pre>
]]></content>
  </entry>
  
</feed>
